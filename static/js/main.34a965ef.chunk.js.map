{"version":3,"sources":["index.ts"],"names":["clientState","ClientState","Disconnected","updateReady","contextId","isReady","readyDiv","document","getElementById","innerHTML","logResponse","type","segmentId","data","logDiv","JSON","stringify","window","onload","client","appId","process","language","Client","debug","newClient","e","status","statusDiv","updateStatus","message","onSegmentChange","segment","words","entities","intent","map","word","isFinal","value","join","index","entity","t","startPosition","endPosition","onTentativeIntent","cid","sid","onTentativeEntities","onTentativeTranscript","transcript","onIntent","onEntity","onTranscript","initDiv","recordDiv","startRecording","event","preventDefault","startContext","err","console","error","resetState","stopRecording","stopContext","addEventListener","onStateChange","state","Connected","setAttribute","removeAttribute","Stopping","stateToString","bindStartStop","initialize","button","target","undefined","close","bindInitialize"],"mappings":"+LAAA,kBASIA,EAAcC,cAAYC,aA4G9B,SAASC,EAAYC,EAAmBC,GACtC,IAAMC,EAAWC,SAASC,eAAe,SAGvCF,EAASG,UADPJ,EACF,yBAAuCD,EAAvC,UAEA,yBAAuCA,GAI3C,SAASM,EACPC,EACAP,EACAQ,EACAC,GAEA,IAAMC,EAASP,SAASC,eAAe,YAEvCM,EAAOL,UACL,8BACYL,EADZ,gCAEYQ,EAFZ,gCAGYD,EAHZ,gCAIYI,KAAKC,UAAUH,GAJ3B,wBAKaC,EAAOL,UAlIxBQ,OAAOC,OAAS,WACd,IAAIC,EAEJ,IACEA,EA2CJ,WACE,IAAMC,EAAQC,uCACVD,EAKAE,EAIJ,OAAO,IAAIC,SAAO,CAChBH,QACAE,SAPeD,QAQfG,OAAO,IAzDEC,GACT,MAAOC,GAEP,YA8HJ,SAAsBC,GACpB,IAAMC,EAAYrB,SAASC,eAAe,UAC1C,GAAkB,OAAdoB,EACF,OAGFA,EAAUnB,UAAYkB,EArIpBE,CAAaH,EAAEI,SAKjBX,EAAOY,iBAAgB,SAACC,GAsD1B,IAAqBC,EAmBGC,EAcFC,EAjCDF,EArDLD,EAAQC,MAsDA1B,SAASC,eAC7B,oBAGYC,UAAYwB,EACvBG,KAAI,SAACC,GAAD,OAAWA,EAAKC,QAAL,aAAqBD,EAAKE,MAA1B,QAAwCF,EAAKE,SAC5DC,KAAK,KAESjC,SAASC,eAAe,mBAChCC,UAAYwB,EAClBG,KAAI,SAACC,GAAD,OACHA,EAAKC,QAAL,iBACcD,EAAKE,MADnB,aAC6BF,EAAKI,MADlC,4BAEWJ,EAAKE,MAFhB,aAE0BF,EAAKI,MAF/B,aAIDD,KAAK,IAGcN,EAvELF,EAAQE,SAwEL3B,SAASC,eAAe,iBAEhCC,UAAYyB,EACrBE,KAAI,SAACM,GACJ,IAAMC,EAAC,UAAMD,EAAO/B,KAAb,cAAuB+B,EAAOH,MAA9B,aAAwCG,EAAOE,cAA/C,cAAkEF,EAAOG,YAAzE,KACP,OAAIH,EAAOJ,QACH,UAAN,OAAiBK,EAAjB,aAEI,OAAN,OAAcA,EAAd,YAEDH,KAAK,IAGYL,EApFLH,EAAQG,OAqFL5B,SAASC,eAAe,gBAEhCC,UAAY0B,EAAOG,QAAP,aACZH,EAAOA,OADK,QAElBA,EAAOA,OAvFLH,EAAQM,SACVnC,EAAY6B,EAAQ5B,WAAW,MAKnCe,EAAO2B,mBAAkB,SAACC,EAAKC,EAAKb,GAAX,OACvBzB,EAAY,mBAAoBqC,EAAKC,EAAK,CAAEb,cAE9ChB,EAAO8B,qBAAoB,SAACF,EAAKC,EAAKd,GAAX,OACzBxB,EAAY,qBAAsBqC,EAAKC,EAAK,CAAEd,gBAEhDf,EAAO+B,uBAAsB,SAACH,EAAKC,EAAKf,EAAOkB,GAAlB,OAC3BzC,EAAY,uBAAwBqC,EAAKC,EAAK,CAAEf,QAAOkB,kBAIzDhC,EAAOiC,UAAS,SAACL,EAAKC,EAAKb,GAAX,OACdzB,EAAY,SAAUqC,EAAKC,EAAK,CAAEb,cAEpChB,EAAOkC,UAAS,SAACN,EAAKC,EAAKN,GAAX,OACdhC,EAAY,SAAUqC,EAAKC,EAAK,CAAEN,cAEpCvB,EAAOmC,cAAa,SAACP,EAAKC,EAAKX,GAAX,OAClB3B,EAAY,aAAcqC,EAAKC,EAAK,CAAEX,YAsG1C,SAAuBlB,GACrB,IAAMoC,EAAUhD,SAASC,eAAe,cAElCgD,EAAYjD,SAASC,eAAe,UAyB1C,SAASiD,EAAeC,GACtBA,EAAMC,iBAENxC,EAAOyC,cAAa,SAACC,EAAKzD,GACpByD,EACFC,QAAQC,MAAM,4BAA6BF,GAqDnD,SAAoBzD,GAClBD,EAAYC,GAAW,GAEJG,SAASC,eAAe,oBAChCC,UAAY,GAEAF,SAASC,eAC9B,mBAEaC,UAAY,GAEXF,SAASC,eAAe,YAChCC,UAAY,GAECF,SAASC,eAAe,iBAChCC,UAAY,GAhErBuD,CAAW5D,MAIf,SAAS6D,EAAcP,GACrBA,EAAMC,iBAENxC,EAAO+C,aAAY,SAACL,GACdA,GACFC,QAAQC,MAAM,2BAA4BF,MA1ChDL,EAAUW,iBAAiB,YAAaV,GACxCD,EAAUW,iBAAiB,aAAcV,GACzCD,EAAUW,iBAAiB,UAAWF,GACtCT,EAAUW,iBAAiB,WAAYF,GAEvC9C,EAAOiD,eAAc,SAACC,GACpBrE,EAAcqE,EAEVA,IAAUpE,cAAYqE,WAAaD,IAAUpE,cAAYC,aAC3DqD,EAAQgB,aAAa,WAAY,YAEjChB,EAAQiB,gBAAgB,YAGtBH,EAAQpE,cAAYqE,WAAaD,IAAUpE,cAAYwE,SACzDjB,EAAUe,aAAa,WAAY,YAEnCf,EAAUgB,gBAAgB,YAGVjE,SAASC,eAAe,UAChCC,UAAYiE,wBAAcL,MA5HtCM,CAAcxD,GAwJhB,SAAwBA,GACtB,IAAMoC,EAAUhD,SAASC,eAAe,cAIxC,SAASoE,EAAWlB,GAClBA,EAAMC,iBACN,IAAMkB,EAASnB,EAAMoB,OAEjB9E,IAAgBC,cAAYC,cAC9BiB,EAAOyD,YAAW,SAACf,QACLkB,IAARlB,EAKJgB,EAAOpE,UAAY,aAJjBqD,QAAQC,MAAM,sCAAuCF,MAQvD7D,IAAgBC,cAAYqE,WAC9BnD,EAAO6D,OAAM,SAACnB,QACAkB,IAARlB,EAKJgB,EAAOpE,UAAY,UAJjBqD,QAAQC,MAAM,sCAAuCF,MArB7DN,EAAQY,iBAAiB,YAAaS,GACtCrB,EAAQY,iBAAiB,aAAcS,GA1JvCK,CAAe9D,M","file":"static/js/main.34a965ef.chunk.js","sourcesContent":["import {\n  Client,\n  ClientState,\n  stateToString,\n  Word,\n  Entity,\n  Intent,\n} from \"@speechly/browser-client\";\n\nlet clientState = ClientState.Disconnected;\n\nwindow.onload = () => {\n  let client: Client;\n\n  try {\n    client = newClient();\n  } catch (e) {\n    updateStatus(e.message);\n    return;\n  }\n\n  // High-level API, that you can use to react to segment changes.\n  client.onSegmentChange((segment) => {\n    updateWords(segment.words);\n    updateEntities(segment.entities);\n    updateIntent(segment.intent);\n\n    if (segment.isFinal) {\n      updateReady(segment.contextId, true);\n    }\n  });\n\n  // This is low-level API, that you can use to react to tentative events.\n  client.onTentativeIntent((cid, sid, intent) =>\n    logResponse(\"tentative_intent\", cid, sid, { intent })\n  );\n  client.onTentativeEntities((cid, sid, entities) =>\n    logResponse(\"tentative_entities\", cid, sid, { entities })\n  );\n  client.onTentativeTranscript((cid, sid, words, transcript) =>\n    logResponse(\"tentative_transcript\", cid, sid, { words, transcript })\n  );\n\n  // This is low-level API, that you can use to react to final events.\n  client.onIntent((cid, sid, intent) =>\n    logResponse(\"intent\", cid, sid, { intent })\n  );\n  client.onEntity((cid, sid, entity) =>\n    logResponse(\"entity\", cid, sid, { entity })\n  );\n  client.onTranscript((cid, sid, word) =>\n    logResponse(\"transcript\", cid, sid, { word })\n  );\n\n  bindStartStop(client);\n  bindInitialize(client);\n};\n\nfunction newClient(): Client {\n  const appId = process.env.REACT_APP_APP_ID;\n  if (appId === undefined) {\n    throw Error(\"Missing Speechly App ID!\");\n  }\n\n  const language = process.env.REACT_APP_LANGUAGE;\n  if (language === undefined) {\n    throw Error(\"Missing Speechly language!\");\n  }\n\n  return new Client({\n    appId,\n    language,\n    debug: true,\n  });\n}\n\nfunction updateWords(words: Word[]) {\n  const transcriptDiv = document.getElementById(\n    \"transcript-words\"\n  ) as HTMLElement;\n\n  transcriptDiv.innerHTML = words\n    .map((word) => (word.isFinal ? `<b>${word.value}</b>` : word.value))\n    .join(\" \");\n\n  const wordsDiv = document.getElementById(\"transcript-list\") as HTMLElement;\n  wordsDiv.innerHTML = words\n    .map((word) =>\n      word.isFinal\n        ? `<li><b>${word.value} [${word.index}]</b></li>`\n        : `<li>${word.value} [${word.index}]</li>`\n    )\n    .join(\"\");\n}\n\nfunction updateEntities(entities: Entity[]) {\n  const entitiesDiv = document.getElementById(\"entities-list\") as HTMLElement;\n\n  entitiesDiv.innerHTML = entities\n    .map((entity) => {\n      const t = `${entity.type} - ${entity.value} [${entity.startPosition} - ${entity.endPosition})`;\n      if (entity.isFinal) {\n        return `<li><b>${t}</b></li>`;\n      }\n      return `<li>${t}</li>`;\n    })\n    .join(\"\");\n}\n\nfunction updateIntent(intent: Intent) {\n  const intentDiv = document.getElementById(\"intent-value\") as HTMLElement;\n\n  intentDiv.innerHTML = intent.isFinal\n    ? `<b>${intent.intent}</b>`\n    : intent.intent;\n}\n\nfunction updateReady(contextId: string, isReady: boolean) {\n  const readyDiv = document.getElementById(\"final\") as HTMLElement;\n\n  if (isReady) {\n    readyDiv.innerHTML = `<b>Context</b> ${contextId} Done!`;\n  } else {\n    readyDiv.innerHTML = `<b>Context</b> ${contextId}`;\n  }\n}\n\nfunction logResponse(\n  type: string,\n  contextId: string,\n  segmentId: number,\n  data: any\n) {\n  const logDiv = document.getElementById(\"log-list\") as HTMLElement;\n\n  logDiv.innerHTML =\n    `<tr>\n          <td>${contextId}</td>\n          <td>${segmentId}</td>\n          <td>${type}</td>\n          <td>${JSON.stringify(data)}</td>\n        </tr>` + logDiv.innerHTML;\n}\n\nfunction updateStatus(status: string): void {\n  const statusDiv = document.getElementById(\"status\");\n  if (statusDiv === null) {\n    return;\n  }\n\n  statusDiv.innerHTML = status;\n}\n\nfunction bindStartStop(client: Client) {\n  const initDiv = document.getElementById(\"initialize\") as HTMLElement;\n\n  const recordDiv = document.getElementById(\"record\") as HTMLElement;\n  recordDiv.addEventListener(\"mousedown\", startRecording);\n  recordDiv.addEventListener(\"touchstart\", startRecording);\n  recordDiv.addEventListener(\"mouseup\", stopRecording);\n  recordDiv.addEventListener(\"touchend\", stopRecording);\n\n  client.onStateChange((state) => {\n    clientState = state;\n\n    if (state !== ClientState.Connected && state !== ClientState.Disconnected) {\n      initDiv.setAttribute(\"disabled\", \"disabled\");\n    } else {\n      initDiv.removeAttribute(\"disabled\");\n    }\n\n    if (state < ClientState.Connected || state === ClientState.Stopping) {\n      recordDiv.setAttribute(\"disabled\", \"disabled\");\n    } else {\n      recordDiv.removeAttribute(\"disabled\");\n    }\n\n    const statusDiv = document.getElementById(\"status\") as HTMLElement;\n    statusDiv.innerHTML = stateToString(state);\n  });\n\n  function startRecording(event: MouseEvent | TouchEvent) {\n    event.preventDefault();\n\n    client.startContext((err, contextId) => {\n      if (err) {\n        console.error(\"Could not start recording\", err);\n        return;\n      }\n\n      resetState(contextId as string);\n    });\n  }\n\n  function stopRecording(event: MouseEvent | TouchEvent) {\n    event.preventDefault();\n\n    client.stopContext((err) => {\n      if (err) {\n        console.error(\"Could not stop recording\", err);\n        return;\n      }\n    });\n  }\n}\n\nfunction bindInitialize(client: Client) {\n  const initDiv = document.getElementById(\"initialize\") as HTMLElement;\n  initDiv.addEventListener(\"mousedown\", initialize);\n  initDiv.addEventListener(\"touchstart\", initialize);\n\n  function initialize(event: MouseEvent | TouchEvent) {\n    event.preventDefault();\n    const button = event.target as HTMLElement;\n\n    if (clientState === ClientState.Disconnected) {\n      client.initialize((err?: Error) => {\n        if (err !== undefined) {\n          console.error(\"Error initializing Speechly client:\", err);\n          return;\n        }\n\n        button.innerHTML = \"Disconnect\";\n      });\n    }\n\n    if (clientState === ClientState.Connected) {\n      client.close((err?: Error) => {\n        if (err !== undefined) {\n          console.error(\"Error initializing Speechly client:\", err);\n          return;\n        }\n\n        button.innerHTML = \"Connect\";\n      });\n    }\n  }\n}\n\nfunction resetState(contextId: string) {\n  updateReady(contextId, false);\n\n  const transcript = document.getElementById(\"transcript-words\") as HTMLElement;\n  transcript.innerHTML = \"\";\n\n  const transcriptList = document.getElementById(\n    \"transcript-list\"\n  ) as HTMLElement;\n  transcriptList.innerHTML = \"\";\n\n  const logList = document.getElementById(\"log-list\") as HTMLElement;\n  logList.innerHTML = \"\";\n\n  const entitiesList = document.getElementById(\"entities-list\") as HTMLElement;\n  entitiesList.innerHTML = \"\";\n}\n"],"sourceRoot":""}